# Language Translator
---

In a language like `C`, A language translator translates the code into machine code (1's and 0's). It goes through four different phases. __Preprocessing, Compiler, Assembler, Linker/Loader__.

```c

#include <stdio.h> //Header file for printf()

int main() // main function
{
	int x, a=2, b=3, c=5;
	x = a+b*c;
	printf("The value of x is %d", x);

	return 0
}
```
We will go through the different phases of a language translator and see how this code will turn into machine code.
## 1. Preprocessing

In a compiler, a **preprocessor** performs initial processing on the source code before the actual compilation begins. The main tasks of a preprocessor include:
1. __Macro Expansion:__ Replaces macros, which are symbolic names for code snippets with their defined content. For example, in C, `#define PI 3.14` would replace all instances of `PI` with 3.14
2. __File Inclusion__: Incorporate the contents of other files into the source through directives like `#include`. This allows for reusable code, such as including standard libraries or custom headers.
3. **Conditional Compilation**: Compiles specific sections of code based on defined conditions, often using directives like `#ifdef`, `#ifndef`, and `#endif`. This helps in compiling code only for certain platforms.
4. **Removing Comments**: Strips comments from the source code to make it easier for the compiler to process without the extra text.
5. **Other textual Substitutions**: Handles other preprocessing instructions that direct the compiler to make substitutions or alterations.

The result of preprocessing is "cleaned up _or_ Pure High Level Language" code that the compiler can then translate into an intermediate or machine representation.

In our example the code would be represented in a way like this:
```c
int main()
{
	int x, a=2, b=3, c=5;
	x = a+b*c;
	printf("The value of x is %d", x);

	return 0
}
```


## 2. Compiler

This phase will take our [[Introduction to Compiler Design#1. Preprocessing| Pure High Level Language Code]] and generate the equivalent **Assembly Code**.

```nasm

.LC0:
    .string "The value of x is %d"

main:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     DWORD PTR [rbp-4], 2
    mov     DWORD PTR [rbp-8], 3
    mov     DWORD PTR [rbp-12], 5
    mov     eax, DWORD PTR [rbp-8]
    imul    eax, DWORD PTR [rbp-12]
    mov     edx, eax
    mov     eax, DWORD PTR [rbp-4]
    add     eax, edx
    mov     DWORD PTR [rbp-16], eax
    mov     eax, DWORD PTR [rbp-16]
    mov     esi, eax
    mov     edi, OFFSET FLAT:.LC0
    mov     eax, 0
    call    printf
    mov     eax, 0
    leave
    ret
```

## 3. Assembler

In a compiler, an **assembler** is a component that translates assembly language code (generated by the compiler's code generation phase) into **_relocatable_[^1] machine code**, which is the binary code that the processor can directly execute. Hereâ€™s a breakdown of its main functions:

1. **Converts Assembly Code to Machine Code**: Assembly Language uses human-readable mnemonics (like `mov`, `add`, `push`) that correspond to machine instructions. The assembler translates these mnemonics into their binary equivalents, producing machine code that the CPU can run.
2. **Allocates Memory for Variables and Constants**: The assembler allocates memory space for variables, constants, and other data defined in the code, so each has a specific memory address in the final executable.
3. **Generates Object Files**: The output of the assembler is often an object file, which contains machine code, data, and information about unresolved symbols (like addresses of functions or variables). Object files are later linked together to create the final executable.
4. **Handles Symbol Resolution**: Assemblers assign memory locations to labels and variables within a single source file. However, any symbols refer to external code (such as library functions) remain unresolved until the linker phase.

The Relocatable Machine code could look something like this
```mathematica
i+0: 0001010101
i+1: 0110101001
i+2: 0111101101
i+3: 1110110101
.
.
```

In summary, the assembler bridges the gap between human-readable assembly code and raw machine code that can be executed by the hardware.

## 4. Linker/Loader

**Linker Phase** in a compiler is responsible for combining multiple pieces of object code (compiled source files and libraries) into a single, executables program. The linker resolves symbols and addresses, enabling the program to be loaded and run by the operating system.

>[!note] Keep in Mind:
>During this phase the machine code is given an absolute address in memory

```mathematica
0x00004b8: 0110101010101
0x00004B9: 0101011101111
0x00004BA: 1110110101101
...
...
```

# Compiler - Internal Architecture
---
A Compiler has six different [[Introduction to Compiler Design#Phases of a Compiler|Phases]]: **Lexical Analysis, Syntax Analysis, Semantic Analysis, Intermediate Code Generation, Code Optimization, Target Code Generation**.

Alongside these six phases, a compiler has two more components: **[[Introduction to Compiler Design#Symbol Table Manager & Error Handler|Symbol Table Manager & Error Handler]]**

## Phases of a Compiler

**Phase Wise**, The architecture of a compiler can be divided into two phases:
- **Analysis Phase**: which contain **Lexical Analysis, Syntax Analysis, Semantic Analysis**.
- **Synthesis Phase**: Containing  **Intermediate Code Generation, Code Optimization, Target Code Generation**.

From a **Software Perspective** The architecture of a compiler can be divided into:
- **Front-End**: Which consists of **Lexical Analysis, Syntax Analysis, Semantic Analysis & Intermediate Code Generation**.
- **Back-End**: Which contains **Code Optimization, Target Code Generation**.

>[!note] Note:
>Splitting the compiler into **frontend** and **backend** enables modularity, reusability, and adaptability across languages and architectures. This design allows compiler developers to focus on specific aspects of language processing or hardware optimization independently, simplifying development and maintenance while improving code generation efficiency. (i.e. if we were to Make a compiler for both MacOS and Windows, we only need to modify the backend for the specifications of the targeted operating system and CPU architecture)

## Symbol Table Manager & Error Handler

**Symbol Table Manager**: Stores information gathered from **Analysis Phase** and is used by **Synthesis Phase**
**Error Handler**: Deals with error detection and recovery

![[Compiler Architecture.png]]






---
[^1]: At this stage the sequence of machine instructions can be loaded at different memory addresses without modification. This flexibility allows the program or parts of it to be placed at any memory address when it is ultimately loaded into memory by the operating system. This is crucial for modularity and allows code reuse across different programs.

